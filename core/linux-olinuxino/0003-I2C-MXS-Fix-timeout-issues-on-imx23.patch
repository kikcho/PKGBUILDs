From 82ef4b079d8ff3553fd4790a719bdc56b92becc5 Mon Sep 17 00:00:00 2001
From: Kiril Zyapkov <kiril.zyapkov@gmail.com>
Date: Fri, 10 May 2013 04:45:43 +0300
Subject: [PATCH 3/4] I2C: MXS: Fix timeout issues on imx23

---
 drivers/i2c/busses/i2c-mxs.c | 63 +++++++++++++++++++++++++++++++++-----------
 1 file changed, 48 insertions(+), 15 deletions(-)

diff --git a/drivers/i2c/busses/i2c-mxs.c b/drivers/i2c/busses/i2c-mxs.c
index 120f246..271c434 100644
--- a/drivers/i2c/busses/i2c-mxs.c
+++ b/drivers/i2c/busses/i2c-mxs.c
@@ -14,6 +14,7 @@
  *
  */
 
+#include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/device.h>
 #include <linux/module.h>
@@ -65,10 +66,10 @@
 #define MXS_I2C_CTRL1_SLAVE_STOP_IRQ		0x02
 #define MXS_I2C_CTRL1_SLAVE_IRQ			0x01
 
-#define MXS_I2C_DATA		(0xa0)
+#define MXS_I2C_DATA(i)		(is_imx23_i2c(i) ? 0x60 : 0xa0)
 
-#define MXS_I2C_DEBUG0		(0xb0)
-#define MXS_I2C_DEBUG0_CLR	(0xb8)
+#define MXS_I2C_DEBUG0(i)	(is_imx23_i2c(i) ? 0x70 : 0xb0)
+#define MXS_I2C_DEBUG0_CLR(i)	(is_imx23_i2c(i) ? 0x78 : 0xb8)
 
 #define MXS_I2C_DEBUG0_DMAREQ	0x80000000
 
@@ -93,6 +94,24 @@
 #define MXS_CMD_I2C_READ	(MXS_I2C_CTRL0_SEND_NAK_ON_LAST | \
 				 MXS_I2C_CTRL0_MASTER_MODE)
 
+enum mxs_i2c_type {
+	IMX23_I2C,
+	IMX28_I2C,
+};
+
+static struct platform_device_id mxs_i2c_devtype[] = {
+	{ .name = "mxs-i2c-imx23", .driver_data = IMX23_I2C },
+	{ .name = "mxs-i2c-imx28", .driver_data = IMX28_I2C },
+	{ /* sentinel */ }
+};
+
+static const struct of_device_id mxs_i2c_dt_ids[] = {
+	{ .compatible = "fsl,imx23-i2c", .data = &mxs_i2c_devtype[IMX23_I2C] },
+	{ .compatible = "fsl,imx28-i2c", .data = &mxs_i2c_devtype[IMX28_I2C] },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxs_i2c_dt_ids);
+
 /**
  * struct mxs_i2c_dev - per device, private MXS-I2C data
  *
@@ -108,6 +127,7 @@ struct mxs_i2c_dev {
 	struct completion cmd_complete;
 	int cmd_err;
 	struct i2c_adapter adapter;
+	enum mxs_i2c_type devtype;
 
 	uint32_t timing0;
 	uint32_t timing1;
@@ -122,6 +142,16 @@ struct mxs_i2c_dev {
 	bool				dma_read;
 };
 
+static inline int is_imx23_i2c(struct mxs_i2c_dev *i2c)
+{
+	return i2c->devtype == IMX23_I2C;
+}
+
+static inline int is_imx28_i2c(struct mxs_i2c_dev *i2c)
+{
+	return i2c->devtype == IMX28_I2C;
+}
+
 static void mxs_i2c_reset(struct mxs_i2c_dev *i2c)
 {
 	stmp_reset_block(i2c->regs);
@@ -290,14 +320,14 @@ static int mxs_i2c_pio_wait_dmareq(struct mxs_i2c_dev *i2c)
 {
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 
-	while (!(readl(i2c->regs + MXS_I2C_DEBUG0) &
+	while (!(readl(i2c->regs + MXS_I2C_DEBUG0(i2c)) &
 		MXS_I2C_DEBUG0_DMAREQ)) {
 		if (time_after(jiffies, timeout))
 			return -ETIMEDOUT;
 		cond_resched();
 	}
 
-	writel(MXS_I2C_DEBUG0_DMAREQ, i2c->regs + MXS_I2C_DEBUG0_CLR);
+	writel(MXS_I2C_DEBUG0_DMAREQ, i2c->regs + MXS_I2C_DEBUG0_CLR(i2c));
 
 	return 0;
 }
@@ -348,7 +378,7 @@ static int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,
 		if (ret)
 			return ret;
 
-		writel(addr_data, i2c->regs + MXS_I2C_DATA);
+		writel(addr_data, i2c->regs + MXS_I2C_DATA(i2c));
 
 		ret = mxs_i2c_pio_wait_cplt(i2c);
 		if (ret)
@@ -364,7 +394,8 @@ static int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,
 				ret = mxs_i2c_pio_wait_dmareq(i2c);
 				if (ret)
 					return ret;
-				data = readl(i2c->regs + MXS_I2C_DATA);
+				udelay(200);
+				data = readl(i2c->regs + MXS_I2C_DATA(i2c));
 			}
 			msg->buf[i] = data & 0xff;
 			data >>= 8;
@@ -390,7 +421,7 @@ static int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,
 				ret = mxs_i2c_pio_wait_dmareq(i2c);
 				if (ret)
 					return ret;
-				writel(data, i2c->regs + MXS_I2C_DATA);
+				writel(data, i2c->regs + MXS_I2C_DATA(i2c));
 			}
 		}
 
@@ -400,7 +431,7 @@ static int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,
 			ret = mxs_i2c_pio_wait_dmareq(i2c);
 			if (ret)
 				return ret;
-			writel(data, i2c->regs + MXS_I2C_DATA);
+			writel(data, i2c->regs + MXS_I2C_DATA(i2c));
 		}
 	}
 
@@ -462,6 +493,7 @@ static int mxs_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,
 	}
 
 	dev_dbg(i2c->dev, "Done with err=%d\n", ret);
+	mxs_i2c_reset(i2c);
 
 	return ret;
 
@@ -601,6 +633,8 @@ static int mxs_i2c_get_ofdata(struct mxs_i2c_dev *i2c)
 
 static int mxs_i2c_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *of_id =
+		of_match_device(mxs_i2c_dt_ids, &pdev->dev);
 	struct device *dev = &pdev->dev;
 	struct mxs_i2c_dev *i2c;
 	struct i2c_adapter *adap;
@@ -618,6 +652,11 @@ static int mxs_i2c_probe(struct platform_device *pdev)
 	if (!i2c)
 		return -ENOMEM;
 
+	if (of_id) {
+		pdev->id_entry = of_id->data;
+		i2c->devtype = pdev->id_entry->driver_data;
+	}
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(pdev, 0);
 	dmairq = platform_get_irq(pdev, 1);
@@ -700,12 +739,6 @@ static int mxs_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id mxs_i2c_dt_ids[] = {
-	{ .compatible = "fsl,imx28-i2c", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, mxs_i2c_dt_ids);
-
 static struct platform_driver mxs_i2c_driver = {
 	.driver = {
 		   .name = DRIVER_NAME,
-- 
1.8.2.2

